<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPHome Mesh Architect | Final Release</title>
    <style>
        :root { 
            --bg: #0f172a; --panel: #1e293b; --border: #334155; 
            --text: #f8fafc; --accent: #3b82f6; --success: #10b981; 
        }
        body { 
            background: var(--bg); color: var(--text); 
            font-family: 'SF Mono', 'Segoe UI Mono', 'Courier New', monospace;
            margin: 0; padding: 20px; display: flex; flex-direction: column; height: 100vh;
        }
        
        /* Layout */
        .header { 
            display: flex; justify-content: space-between; align-items: center; 
            padding-bottom: 20px; border-bottom: 1px solid var(--border);
        }
        .header h1 { margin: 0; font-size: 1.2rem; letter-spacing: -0.5px; }
        .tag { background: var(--accent); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; }

        .workspace { display: grid; grid-template-columns: 320px 1fr; gap: 20px; flex: 1; margin-top: 20px; overflow: hidden; }
        
        /* Sidebar */
        .config-panel { 
            background: var(--panel); border: 1px solid var(--border); 
            padding: 20px; border-radius: 8px; overflow-y: auto; 
        }
        
        .form-group { margin-bottom: 20px; }
        label { display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 6px; }
        input, select { 
            width: 100%; background: var(--bg); border: 1px solid var(--border); 
            color: white; padding: 10px; border-radius: 4px; font-family: inherit; 
        }
        input:focus, select:focus { outline: 2px solid var(--accent); border-color: transparent; }
        
        .hint { font-size: 0.75rem; color: #64748b; margin-top: 5px; line-height: 1.4; }
        
        button.generate-btn {
            background: var(--success); color: #022c22; border: none; padding: 12px;
            width: 100%; font-weight: bold; border-radius: 4px; cursor: pointer;
            transition: opacity 0.2s;
        }
        button.generate-btn:hover { opacity: 0.9; }

        /* Code Area */
        .code-area { 
            background: #0b0e14; border: 1px solid var(--border); border-radius: 8px; 
            display: flex; flex-direction: column; overflow: hidden; 
        }
        
        .tabs { display: flex; background: var(--panel); border-bottom: 1px solid var(--border); }
        .tab { 
            padding: 12px 20px; cursor: pointer; color: #94a3b8; font-size: 0.9rem; border-right: 1px solid var(--border); 
            transition: background 0.2s;
        }
        .tab:hover { background: #283547; }
        .tab.active { background: #0b0e14; color: var(--accent); border-top: 2px solid var(--accent); }
        
        pre { 
            flex: 1; margin: 0; padding: 20px; overflow: auto; 
            font-size: 13px; line-height: 1.6; color: #e2e8f0; 
        }
        
        /* Syntax Highlight Colors (Simplified) */
        .kw { color: #c678dd; } /* Keyword */
        .str { color: #98c379; } /* String */
        .def { color: #e06c75; } /* Define/Type */
        .com { color: #5c6370; font-style: italic; } /* Comment */
    </style>
</head>
<body>

    <div class="header">
        <div>
            <h1>ESPHome Mesh Architect</h1>
            <div style="font-size: 0.8rem; color: #64748b; margin-top: 4px;">Zero-Config • Auto-Scan • Dynamic LMK</div>
        </div>
        <span class="tag">Final Release</span>
    </div>

    <div class="workspace">
        <!-- Configuration -->
        <aside class="config-panel">
            <div class="form-group">
                <label>Ruolo Nodo</label>
                <select id="role" onchange="render()">
                    <option value="ROOT">ROOT (Gateway MQTT + WiFi)</option>
                    <option value="NODE">NODE (Zero-Config Sensor)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Mesh ID (Univoco)</label>
                <input type="text" id="mesh_id" value="SmartHome_Mesh" oninput="render()">
            </div>

            <div class="form-group">
                <label>Master Key (PMK)</label>
                <input type="text" id="pmk" value="SecretKey1234567" maxlength="16" oninput="render()">
                <div class="hint">Usata per l'handshake iniziale e per derivare le chiavi univoche (LMK).</div>
            </div>

            <div id="root_options">
                <div class="form-group">
                    <label>Broker MQTT</label>
                    <input type="text" id="mqtt" value="192.168.1.10" oninput="render()">
                </div>
            </div>

            <div class="form-group">
                <div class="hint">
                    <strong>Auto-Scan Attivo:</strong> Il nodo non richiede configurazione canali. Al boot scansiona 1-13 cercando il Root e si aggancia automaticamente.
                </div>
            </div>

            <button class="generate-btn" onclick="copyToClipboard()">Copia Codice Attivo</button>
        </aside>

        <!-- Output -->
        <main class="code-area">
            <div class="tabs">
                <div class="tab active" onclick="setTab('yaml')">config.yaml</div>
                <div class="tab" onclick="setTab('py')">__init__.py</div>
                <div class="tab" onclick="setTab('h')">mesh.h</div>
                <div class="tab" onclick="setTab('cpp')">mesh.cpp</div>
            </div>
            <pre id="output_code">// Caricamento...</pre>
        </main>
    </div>

    <script>
        // State
        let currentTab = 'yaml';
        const files = { yaml: '', py: '', h: '', cpp: '' };

        // --- GENERATORS PART 1 ---

function genPy(c) {
            return `import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.const import CONF_ID, CONF_MODE, CONF_CHANNEL

# --- BEST PRACTICES: COSTANTI E NAMESPACE ---
CONF_MESH_ID = 'mesh_id'
CONF_PMK = 'pmk'

# Definiamo il namespace C++
mesh_ns = cg.esphome_ns.namespace('esp_mesh')
EspMesh = mesh_ns.class_('EspMesh', cg.Component)

# --- AUTO LOADING ---
# Carica automaticamente i componenti interni necessari.
# Questo evita l'errore VCSBaseException e rende disponibili gli header C++
AUTO_LOAD = ['esp32', 'sensor', 'switch', 'binary_sensor', 'text_sensor']

# --- CONFIGURATION VALIDATION ---
# Usiamo cv.All per combinare lo Schema a dizionario con il controllo di piattaforma
CONFIG_SCHEMA = cv.All(
    cv.Schema({
        cv.GenerateID(): cv.declare_id(EspMesh),
        cv.Required(CONF_MODE): cv.enum({'ROOT': 0, 'NODE': 1}),
        cv.Required(CONF_MESH_ID): cv.string,
        cv.Required(CONF_PMK): cv.All(cv.string, cv.Length(min=16, max=16)),
    }).extend(cv.COMPONENT_SCHEMA),
    
    # Questo validatore va messo FUORI dal dizionario, dentro cv.All
    cv.only_on(['esp32'])
)

async def to_code(config):
    var = cg.new_Pvariable(config[CONF_ID])
    await cg.register_component(var, config)
    
    cg.add(var.set_mesh_id(config[CONF_MESH_ID]))
    cg.add(var.set_pmk(config[CONF_PMK]))

    # --- LOGICA DI GENERAZIONE CODICE ---
    if config[CONF_MODE] == 0: # ROOT
        cg.add_define('IS_ROOT')
        
        # VALIDAZIONE CROSS-COMPONENT (Safe Check)
        if 'mqtt' not in cg.get_variable_ids():
            raise cv.Invalid("Il Nodo ROOT richiede la presenza del componente 'mqtt:' nella configurazione.")
        if 'wifi' not in cg.get_variable_ids():
            raise cv.Invalid("Il Nodo ROOT richiede la presenza del componente 'wifi:' per connettersi al Broker.")

        mqtt = await cg.get_variable(cg.get_variable_ids()['mqtt'])
        cg.add(var.set_mqtt(mqtt))
        
    else: # NODE
        cg.add_define('IS_NODE')
        # Se nel YAML del nodo c'è un canale fisso (opzionale), lo passiamo
        if CONF_CHANNEL in config:
             cg.add(var.set_channel(config[CONF_CHANNEL]))`;
        }

function genH(c) {
            return `#pragma once
#include "esphome/core/component.h"
#include "esphome/core/application.h"
#include "esphome/core/entity_base.h"
#include <vector>
#include <map>
#include <string>
#include <list>

#ifdef USE_BINARY_SENSOR
#include "esphome/components/binary_sensor/binary_sensor.h"
#endif
#ifdef USE_SENSOR
#include "esphome/components/sensor/sensor.h"
#endif
#ifdef USE_SWITCH
#include "esphome/components/switch/switch.h"
#endif
#ifdef USE_BUTTON
#include "esphome/components/button/button.h"
#endif
#ifdef USE_TEXT_SENSOR
#include "esphome/components/text_sensor/text_sensor.h"
#endif
#ifdef USE_FAN
#include "esphome/components/fan/fan.h"
#endif
#ifdef USE_CLIMATE
#include "esphome/components/climate/climate.h"
#endif
#ifdef USE_LIGHT
#include "esphome/components/light/light_state.h"
#endif
#ifdef USE_COVER
#include "esphome/components/cover/cover.h"
#endif
#ifdef USE_NUMBER
#include "esphome/components/number/number.h"
#endif
#ifdef USE_TEXT
#include "esphome/components/text/text.h"
#endif
#ifdef USE_SELECT
#include "esphome/components/select/select.h"
#endif
#ifdef USE_LOCK
#include "esphome/components/lock/lock.h"
#endif
#ifdef USE_VALVE
#include "esphome/components/valve/valve.h"
#endif
#ifdef USE_ALARM_CONTROL_PANEL
#include "esphome/components/alarm_control_panel/alarm_control_panel.h"
#endif
#ifdef USE_EVENT
#include "esphome/components/event/event.h"
#endif

#ifdef IS_ROOT
#include "esphome/components/mqtt/mqtt_client.h"
#endif

namespace esphome {
namespace esp_mesh {

// Limite di sicurezza peer cifrati (Max HW è 17, teniamo margine)
#define MAX_PEERS 6 

enum PktType : uint8_t {
    PKT_PROBE   = 0x01, 
    PKT_ANNOUNCE= 0x02, 
    PKT_REG     = 0x10, 
    PKT_DATA    = 0x20, 
    PKT_CMD     = 0x30  
};

enum EntityType : uint8_t { 
    ENTITY_TYPE_BINARY_SENSOR   = 0x01, 
    ENTITY_TYPE_SWITCH   = 0x02, 
    ENTITY_TYPE_BUTTON   = 0x03, 
    ENTITY_TYPE_EVENT   = 0x04, 
    ENTITY_TYPE_SENSOR   = 0x05, 
    ENTITY_TYPE_TEXT_SENSOR   = 0x06, 
    ENTITY_TYPE_FAN   = 0x07, 
    ENTITY_TYPE_COVER   = 0x08, 
    ENTITY_TYPE_CLIMATE   = 0x09, 
    ENTITY_TYPE_LIGHT   = 0x0A, 
    ENTITY_TYPE_NUMBER   = 0x0B, 
    ENTITY_TYPE_SELECT   = 0x0F, 
    ENTITY_TYPE_TEXT= 0x10, 
    ENTITY_TYPE_LOCK     = 0x11, 
    ENTITY_TYPE_VALVE    = 0x12, 
    ENTITY_TYPE_ALARM_CONTROL_PANEL    = 0x13
};

struct __attribute__((packed)) MeshHeader {
    uint8_t type;
    uint32_t net_id;
    uint8_t src[6];      // Originator
    uint8_t dst[6];      // Final Destination
    uint8_t next_hop[6]; // Immediate Receiver (Routing)
    uint8_t ttl;         // Time To Live
};

struct __attribute__((packed)) RegPayload {
    uint32_t entity_hash;
    char type_id;
    char name[24];
    char unit[8];
    char dev_class[16];
};

// Routing Entry
struct RouteInfo {
    uint8_t next_hop[6];
    uint32_t last_seen;
};

// Device Component
struct __attribute__((packed)) EntityInfo {
    EntityBase *entity;
    EntityType type;
};

class EspMesh : public Component {
 public:
  void setup() override;
  void loop() override;
  void dump_config() override;
  float get_setup_priority() const override;

  // --- SETTERS (L'interfaccia per Python) ---
  // Python chiamerà questi metodi per passare i dati del YAML
  void set_mesh_id(const std::string &id);
  void set_pmk(const std::string &pmk);
  void set_channel(uint8_t channel); // Solo per Node
  
#ifdef IS_ROOT
  void set_mqtt(mqtt::MQTTClient *m) { mqtt_ = m; }
#endif

 protected:
  std::string pmk_;
  uint32_t net_id_hash_;
  uint8_t my_mac_[6];

  // Routing State
  uint8_t parent_mac_[6];
  uint8_t hop_count_ = 0xFF;
  std::map<std::string, RouteInfo> routes_;
  
  // Peer Management (LRU)
  std::list<std::string> peer_lru_; 

#ifdef IS_NODE
  bool scanning_ = true;
  uint8_t current_scan_ch_ = 1;
  uint32_t last_scan_step_ = 0;
  uint32_t last_announce_sent_ = 0;
  std::vector<EntityInfo> local_entities_{};

  void setup_bare_metal();
  void send_probe();
  void scan_local_entities();
  std::vector<EntityInfo> get_local_entities();    
  template<typename T>
    void add_entities_to_local_list(const T& entities, EntityType type);
#endif

#ifdef IS_ROOT
  mqtt::MQTTClient *mqtt_{nullptr};
  uint32_t last_announce_ = 0;
  void handle_reg(const uint8_t *origin, const RegPayload *p);
  void handle_data(const uint8_t *origin, const uint8_t *payload);
#endif

  // Core Networking
  void on_packet(const uint8_t *mac, const uint8_t *data, int len, int8_t rssi);
  void route_packet(MeshHeader *h, const uint8_t *payload, int len);
  
  // Low Level Helpers
  void send_raw(const uint8_t *next_hop, const uint8_t *data, int len);
  void ensure_peer_slot(const uint8_t *mac);
  void derive_lmk(const uint8_t *mac, uint8_t *lmk);
  uint32_t djb2_hash(const std::string &s);
};

}
}`;
        }

// --- GENERATORS PART 2 (THE ENGINE) ---
function genCpp(c) {
            return `#include "mesh.h"
#include "esphome/core/log.h"
#include <esp_now.h>
#include <esp_wifi.h>
#include <nvs_flash.h>

namespace esphome {
namespace esp_mesh {

static const char *const TAG = "mesh";
static EspMesh *global_mesh = nullptr;

// --- IMPLEMENTAZIONE SETTERS ---
void EspMesh::set_mesh_id(const std::string &id) {
  // Calcoliamo l'hash subito, quando Python ci passa l'ID
  this->net_id_hash_ = djb2_hash(id);
}

void EspMesh::set_pmk(const std::string &pmk) {
  this->pmk_ = pmk;
}

void EspMesh::set_channel(uint8_t channel) {
  this->current_scan_ch_ = channel;
}

uint32_t EspMesh::djb2_hash(const std::string &s) {
  uint32_t h = 5381;
  for (char c : s) {
    h = ((h << 5) + h) + c;
  }
  return h;
}

float EspMesh::get_setup_priority() const {
#ifdef IS_NODE
  return setup_priority::WIFI;
#else
  return setup_priority::AFTER_WIFI;
#endif
}

void EspMesh::setup() {
  global_mesh = this;

#ifdef IS_NODE
  this->setup_bare_metal();
  if (esp_now_init() != ESP_OK) {
    this->mark_failed();
    return;
  }
  // Usiamo la variabile membro pmk_ popolata dal setter
  esp_now_set_pmk(reinterpret_cast<uint8_t *>(const_cast<char *>(this->pmk_.c_str())));
#endif

#ifdef IS_ROOT
  esp_wifi_get_mac(WIFI_IF_STA, this->my_mac_);
  if (esp_now_init() != ESP_OK) {
    this->mark_failed();
    return;
  }
  esp_now_set_pmk(reinterpret_cast<uint8_t *>(const_cast<char *>(this->pmk_.c_str())));
  this->hop_count_ = 0;
#endif

  esp_now_register_recv_cb([](const esp_now_recv_info_t *i, const uint8_t *d, int l) {
    if (global_mesh) {
      global_mesh->on_packet(i->src_addr, d, l, i->rx_ctrl ? i->rx_ctrl->rssi : 0);
    }
  });
  ESP_LOGI(TAG, "Mesh initialized. ID Hash: %08X", this->net_id_hash_);
}

void EspMesh::dump_config() {
  ESP_LOGCONFIG(TAG, "ESP-Mesh Configuration:");
  ESP_LOGCONFIG(TAG, "  Net ID Hash: %08X", this->net_id_hash_);
  ESP_LOGCONFIG(TAG, "  Max Peers: %d", MAX_PEERS);
#ifdef IS_ROOT
  ESP_LOGCONFIG(TAG, "  Role: ROOT (Gateway)");
  ESP_LOGCONFIG(TAG, "  MAC Address: %02X:%02X:%02X:%02X:%02X:%02X", 
                this->my_mac_[0], this->my_mac_[1], this->my_mac_[2], 
                this->my_mac_[3], this->my_mac_[4], this->my_mac_[5]);
#else
  ESP_LOGCONFIG(TAG, "  Role: NODE (Sensor)");
  ESP_LOGCONFIG(TAG, "  Bare Metal WiFi: Active");
#endif
}

void EspMesh::loop() {
  uint32_t now = millis();

  // 1. ANNOUNCE PROPAGATION
  if (this->hop_count_ != 0xFF) {
#ifdef IS_ROOT
    if (now - this->last_announce_ > 5000) {
      this->last_announce_ = now;
      // Broadcast Announce Hop 0
      uint8_t bcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
      MeshHeader h;
      h.type = PKT_ANNOUNCE;
      h.net_id = this->net_id_hash_;
      h.ttl = 1;
      memcpy(h.src, this->my_mac_, 6);
      memcpy(h.dst, bcast, 6);
      uint8_t hop = 0;

      uint8_t buf[sizeof(MeshHeader) + 1];
      memcpy(buf, &h, sizeof(MeshHeader));
      buf[sizeof(MeshHeader)] = hop;
      this->send_raw(bcast, buf, sizeof(buf));
    }
#endif

#ifdef IS_NODE
    // Rebroadcast Announce (Repeater Logic)
    if (now - this->last_announce_sent_ > 5000) {
      this->last_announce_sent_ = now;
      uint8_t bcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
      MeshHeader h;
      h.type = PKT_ANNOUNCE;
      h.net_id = this->net_id_hash_;
      h.ttl = 1;
      memcpy(h.src, this->my_mac_, 6);
      memcpy(h.dst, bcast, 6);
      uint8_t my_h = this->hop_count_;

      uint8_t buf[sizeof(MeshHeader) + 1];
      memcpy(buf, &h, sizeof(MeshHeader));
      buf[sizeof(MeshHeader)] = my_h;
      this->send_raw(bcast, buf, sizeof(buf));
    }
#endif
  }

  // 2. SCANNING LOGIC (NODE ONLY)
#ifdef IS_NODE
  if (this->hop_count_ == 0xFF) {
    if (now - this->last_scan_step_ > 200) {
      this->last_scan_step_ = now;
      this->current_scan_ch_ = (this->current_scan_ch_ % 13) + 1;
      esp_wifi_set_channel(this->current_scan_ch_, WIFI_SECOND_CHAN_NONE);
      this->send_probe();
    }
  }
#endif

  // 3. ROUTE GARBAGE COLLECTOR (Every 60s)
  static uint32_t last_route_gc = 0;
  if (now - last_route_gc > 60000) {
    last_route_gc = now;
    for (auto it = this->routes_.begin(); it != this->routes_.end();) {
      if (now - it->second.last_seen > 300000) {
        it = this->routes_.erase(it);
      } else {
        ++it;
      }
    }
  }
}

void EspMesh::on_packet(const uint8_t *mac, const uint8_t *data, int len, int8_t rssi) {
  if (len < sizeof(MeshHeader))
    return;
  auto *h = reinterpret_cast<const MeshHeader *>(data);
  if (h->net_id != this->net_id_hash_)
    return;

  // 1. REVERSE PATH LEARNING
  if (memcmp(h->src, mac, 6) != 0) {
    std::string src_s(reinterpret_cast<const char *>(h->src), 6);
    RouteInfo r;
    memcpy(r.next_hop, mac, 6);
    r.last_seen = millis();
    this->routes_[src_s] = r;
  }

  // 2. HANDLE ANNOUNCE
  if (h->type == PKT_ANNOUNCE) {
    uint8_t remote_hop = data[sizeof(MeshHeader)];
#ifdef IS_NODE
    if (this->hop_count_ == 0xFF || remote_hop + 1 < this->hop_count_) {
      this->hop_count_ = remote_hop + 1;
      memcpy(this->parent_mac_, h->src, 6);
      ESP_LOGI(TAG, "Parent Found: %02X.. (Hop %d) Ch:%d", mac[0], this->hop_count_,
               this->current_scan_ch_);
      this->scan_local_entities();
    }
#endif
    return;
  }

  // 3. ROUTING DECISION
  bool is_virtual_root = true;
  for (int i = 0; i < 6; i++) {
    if (h->dst[i] != 0)
      is_virtual_root = false;
  }

  bool is_for_me = (memcmp(h->dst, this->my_mac_, 6) == 0);

#ifdef IS_ROOT
  if (is_virtual_root)
    is_for_me = true;
#endif

  bool is_bcast = (h->dst[0] == 0xFF);

  if (is_for_me || is_bcast) {
// PROCESS PAYLOAD
#ifdef IS_ROOT
    if (h->type == PKT_REG) {
      this->handle_reg(h->src, reinterpret_cast<const RegPayload *>(data + sizeof(MeshHeader)));
    } else if (h->type == PKT_DATA) {
      this->handle_data(h->src, data + sizeof(MeshHeader));
    }
#endif
  }

  // FORWARDING
  if (!is_for_me && !is_bcast && h->ttl > 0) {
    uint8_t buf[250];
    if (len > 250) return; 
    memcpy(buf, data, len);
    
    auto *mutable_h = reinterpret_cast<MeshHeader *>(buf);
    mutable_h->ttl--;
    
    this->route_packet(mutable_h, buf + sizeof(MeshHeader), len - sizeof(MeshHeader));
  }
}

void EspMesh::route_packet(MeshHeader *h, const uint8_t *payload, int len) {
  uint8_t next_hop[6];

  if (h->dst[0] == 0xFF) {
    memset(next_hop, 0xFF, 6);
  } else {
    std::string dst_s(reinterpret_cast<const char *>(h->dst), 6);
    if (this->routes_.count(dst_s)) {
      memcpy(next_hop, this->routes_[dst_s].next_hop, 6);
    } else {
// Upstream
#ifdef IS_NODE
      if (this->hop_count_ != 0xFF) {
        memcpy(next_hop, this->parent_mac_, 6);
      } else {
        return;
      }
#else
      return;  // Root has no parent
#endif
    }
  }

  uint8_t buf[250];
  if (sizeof(MeshHeader) + len > 250)
    return;

  memcpy(buf, h, sizeof(MeshHeader));
  memcpy(buf + sizeof(MeshHeader), payload, len);

  this->send_raw(next_hop, buf, sizeof(MeshHeader) + len);
}

// --- PEER MANAGEMENT ---
void EspMesh::ensure_peer_slot(const uint8_t *mac) {
  if (esp_now_is_peer_exist(mac)) {
    std::string s(reinterpret_cast<const char *>(mac), 6);
    this->peer_lru_.remove(s);
    this->peer_lru_.push_back(s);
    return;
  }

  if (this->peer_lru_.size() >= MAX_PEERS) {
    std::string victim_s = this->peer_lru_.front();
#ifdef IS_NODE
    if (this->hop_count_ != 0xFF && memcmp(victim_s.c_str(), this->parent_mac_, 6) == 0) {
      if (this->peer_lru_.size() > 1) {
        auto it = this->peer_lru_.begin();
        it++;
        victim_s = *it;
      } else {
        return;
      }
    }
#endif

    esp_now_del_peer(reinterpret_cast<const uint8_t *>(victim_s.c_str()));
    this->peer_lru_.remove(victim_s);
    ESP_LOGD(TAG, "Evicted peer to make space");
  }

  esp_now_peer_info_t pi = {};
  memcpy(pi.peer_addr, mac, 6);
  pi.channel = (this->hop_count_ == 0xFF) ? this->current_scan_ch_ : 0;
  pi.encrypt = true;
  this->derive_lmk(mac, pi.lmk);

  if (esp_now_add_peer(&pi) == ESP_OK) {
    this->peer_lru_.push_back(std::string(reinterpret_cast<const char *>(mac), 6));
  }
}

void EspMesh::send_raw(const uint8_t *next_hop, const uint8_t *data, int len) {
  bool is_bcast = (next_hop[0] == 0xFF);

  if (!is_bcast) {
    this->ensure_peer_slot(next_hop);
  } else {
    if (!esp_now_is_peer_exist(next_hop)) {
      esp_now_peer_info_t pi = {};
      memcpy(pi.peer_addr, next_hop, 6);
      pi.encrypt = false;
      esp_now_add_peer(&pi);
    }
  }

  esp_now_send(next_hop, data, len);
}

void EspMesh::derive_lmk(const uint8_t *mac, uint8_t *lmk) {
  for (int i = 0; i < 16; i++) {
    lmk[i] = this->pmk_[i] ^ mac[i % 6];
  }
}

#ifdef IS_NODE
void EspMesh::setup_bare_metal() {
  nvs_flash_init();
  esp_netif_init();
  esp_event_loop_create_default();
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_set_mode(WIFI_MODE_STA);
  esp_wifi_set_channel(this->current_scan_ch_, WIFI_SECOND_CHAN_NONE);
  esp_wifi_start();
  esp_wifi_set_ps(WIFI_PS_NONE);
  esp_wifi_get_mac(WIFI_IF_STA, this->my_mac_);
}

void EspMesh::send_probe() {
  uint8_t bcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
  MeshHeader h;
  h.type = PKT_PROBE;
  h.net_id = this->net_id_hash_;
  h.ttl = 1;
  memcpy(h.src, this->my_mac_, 6);
  memcpy(h.dst, bcast, 6);
  this->send_raw(bcast, reinterpret_cast<uint8_t *>(&h), sizeof(h));
}
void EspMesh::scan_local_entities() {
  uint8_t root_dst[6] = {0};

  // --- SCANSIONE E REGISTRAZIONE ENTITÀ LOCALI ---
  // Itera su tutte le entità registrate nel componente
  for (auto obj : this->get_local_entities()) {
    switch(obj.type) {

      // ========== BINARY_SENSOR ==========
      #ifdef USE_BINARY_SENSOR
      case ENTITY_TYPE_BINARY_SENSOR: {
        auto *bs = static_cast<binary_sensor::BinarySensor *>(obj.entity);
        if (bs != nullptr) {
          // 1. Registrazione entità al Root
          RegPayload p;
          p.entity_hash = bs->get_object_id_hash();
          p.type_id = 'B';
          strncpy(p.name, bs->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.dev_class, bs->get_device_class_ref().c_str(), 15);
          p.dev_class[15] = '\0';
          memset(p.unit, 0, 8);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // 2. Registrazione callback per trasmissione dati
          bs->add_on_state_callback([this, bs](bool state) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[5];
            uint32_t hash = bs->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = state ? 1 : 0;

            this->route_packet(&dh, pl, 5);
          });
        }
        break;
      }
      #endif

      // ========== SENSOR ==========
      #ifdef USE_SENSOR
      case ENTITY_TYPE_SENSOR: {
        auto *s = static_cast<sensor::Sensor *>(obj.entity);
        if (s != nullptr) {
          RegPayload p;
          p.entity_hash = s->get_object_id_hash();
          p.type_id = 'S';
          strncpy(p.name, s->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.unit, s->get_unit_of_measurement_ref().c_str(), 7);
          p.unit[7] = '\0';
          strncpy(p.dev_class, s->get_device_class_ref().c_str(), 15);
          p.dev_class[15] = '\0';

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          s->add_on_state_callback([this, s](float val) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[8];
            uint32_t hash = s->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, &val, 4);

            this->route_packet(&dh, pl, 8);
          });
        }
        break;
      }
      #endif

      // ========== SWITCH ==========
      #ifdef USE_SWITCH
      case ENTITY_TYPE_SWITCH: {
        auto *sw = static_cast<switch_::Switch *>(obj.entity);
        if (sw != nullptr) {
          RegPayload p;
          p.entity_hash = sw->get_object_id_hash();
          p.type_id = 'W';
          strncpy(p.name, sw->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          sw->add_on_state_callback([this, sw](bool state) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[5];
            uint32_t hash = sw->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = state ? 1 : 0;

            this->route_packet(&dh, pl, 5);
          });
        }
        break;
      }
      #endif

      // ========== BUTTON ==========
      #ifdef USE_BUTTON
      case ENTITY_TYPE_BUTTON: {
        auto *btn = static_cast<button::Button *>(obj.entity);
        if (btn != nullptr) {
          RegPayload p;
          p.entity_hash = btn->get_object_id_hash();
          p.type_id = 'N';
          strncpy(p.name, btn->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          btn->add_on_press_callback([this, btn]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[4];
            uint32_t hash = btn->get_object_id_hash();
            memcpy(pl, &hash, 4);

            this->route_packet(&dh, pl, 4);
          });
        }
        break;
      }
      #endif

      // ========== TEXT_SENSOR ==========
      #ifdef USE_TEXT_SENSOR
      case ENTITY_TYPE_TEXT_SENSOR: {
        auto *ts = static_cast<text_sensor::TextSensor *>(obj.entity);
        if (ts != nullptr) {
          RegPayload p;
          p.entity_hash = ts->get_object_id_hash();
          p.type_id = 'T';
          strncpy(p.name, ts->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.dev_class, ts->get_device_class_ref().c_str(), 15);
          p.dev_class[15] = '\0';
          memset(p.unit, 0, 8);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          ts->add_on_state_callback([this, ts](const std::string &state) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            size_t state_len = std::min(state.length(), size_t(24));
            uint8_t pl[28];
            uint32_t hash = ts->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, state.c_str(), state_len);
            memset(pl + 4 + state_len, 0, 24 - state_len);

            this->route_packet(&dh, pl, 28);
          });
        }
        break;
      }
      #endif

      // ========== FAN ==========
      #ifdef USE_FAN
      case ENTITY_TYPE_FAN: {
        auto *f = static_cast<fan::Fan *>(obj.entity);
        if (f != nullptr) {
          RegPayload p;
          p.entity_hash = f->get_object_id_hash();
          p.type_id = 'F';
          strncpy(p.name, f->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Fan: invia stato (0=off, 1-speed levels)
          f->add_on_state_callback([this, f]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[6];
            uint32_t hash = f->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = f->state ? 1 : 0;
            pl[5] = static_cast<uint8_t>(f->speed * 255.0f);

            this->route_packet(&dh, pl, 6);
          });
        }
        break;
      }
      #endif

      // ========== COVER (Tenda/Tapparella) ==========
      #ifdef USE_COVER
      case ENTITY_TYPE_COVER: {
        auto *c = static_cast<cover::Cover *>(obj.entity);
        if (c != nullptr) {
          RegPayload p;
          p.entity_hash = c->get_object_id_hash();
          p.type_id = 'C';
          strncpy(p.name, c->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.unit, "%", 7);
          p.unit[7] = '\0';
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Cover: posizione 0-100%
          c->add_on_state_callback([this, c]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[8];
            uint32_t hash = c->get_object_id_hash();
            memcpy(pl, &hash, 4);
            float position = c->position;
            memcpy(pl + 4, &position, 4);

            this->route_packet(&dh, pl, 8);
          });
        }
        break;
      }
      #endif

      // ========== LIGHT (Luce) ==========
      #ifdef USE_LIGHT
      case ENTITY_TYPE_LIGHT: {
        auto *light = static_cast<light::LightState *>(obj.entity);
        if (light != nullptr) {
          RegPayload p;
          p.entity_hash = light->get_object_id_hash();
          p.type_id = 'L';
          strncpy(p.name, light->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Light: stato on/off + brightness (0-255)
          light->add_new_target_state_reached_callback([this, light]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[6];
            uint32_t hash = light->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = light->remote_values.is_on() ? 1 : 0;
            pl[5] = static_cast<uint8_t>(light->remote_values.get_brightness() * 255.0f);

            this->route_packet(&dh, pl, 6);
          });
        }
        break;
      }
      #endif

      // ========== CLIMATE (Termostato) ==========
      #ifdef USE_CLIMATE
      case ENTITY_TYPE_CLIMATE: {
        auto *clim = static_cast<climate::Climate *>(obj.entity);
        if (clim != nullptr) {
          RegPayload p;
          p.entity_hash = clim->get_object_id_hash();
          p.type_id = 'K';
          strncpy(p.name, clim->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.unit, "°C", 7);
          p.unit[7] = '\0';
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Climate: temperatura target + modalità
          clim->add_on_state_callback([this, clim](climate::Climate &) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);
            
            uint8_t pl[6];
            uint32_t hash = clim->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = static_cast<uint8_t>(clim->target_temperature);
            pl[5] = static_cast<uint8_t>(clim->mode);
            
            this->route_packet(&dh, pl, 6);
          });
        }
        break;
      }
      #endif

      // ========== NUMBER (Numero) ==========
      #ifdef USE_NUMBER
      case ENTITY_TYPE_NUMBER: {
        auto *num = static_cast<number::Number *>(obj.entity);
        if (num != nullptr) {
          RegPayload p;
          p.entity_hash = num->get_object_id_hash();
          p.type_id = 'U';
          strncpy(p.name, num->get_name().c_str(), 23);
          p.name[23] = '\0';
          p.unit[0] = '\0';
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          num->add_on_state_callback([this, num](float val) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[8];
            uint32_t hash = num->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, &val, 4);

            this->route_packet(&dh, pl, 8);
          });
        }
        break;
      }
      #endif

      // ========== SELECT (Selezione) ==========
      #ifdef USE_SELECT
      case ENTITY_TYPE_SELECT: {
        auto *sel = static_cast<select::Select *>(obj.entity);
        if (sel != nullptr) {
          RegPayload p;
          p.entity_hash = sel->get_object_id_hash();
          p.type_id = 'E';
          strncpy(p.name, sel->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          sel->add_on_state_callback([this, sel](const std::string &state, size_t index) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);
            
            size_t state_len = std::min(state.length(), size_t(24));
            uint8_t pl[28];
            uint32_t hash = sel->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, state.c_str(), state_len);
            memset(pl + 4 + state_len, 0, 24 - state_len);
            
            this->route_packet(&dh, pl, 28);
          });
        }
        break;
      }
      #endif

      // ========== LOCK (Serratura) ==========
      #ifdef USE_LOCK
      case ENTITY_TYPE_LOCK: {
        auto *lock = static_cast<lock::Lock *>(obj.entity);
        if (lock != nullptr) {
          RegPayload p;
          p.entity_hash = lock->get_object_id_hash();
          p.type_id = 'O';
          strncpy(p.name, lock->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Lock: locked/unlocked state
          lock->add_on_state_callback([this, lock]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[5];
            uint32_t hash = lock->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = static_cast<uint8_t>(lock->state);

            this->route_packet(&dh, pl, 5);
          });
        }
        break;
      }
      #endif

      // ========== TEXT (Testo) ==========
      #ifdef USE_TEXT
      case ENTITY_TYPE_TEXT: {
        auto *txt = static_cast<text::Text *>(obj.entity);
        if (txt != nullptr) {
          RegPayload p;
          p.entity_hash = txt->get_object_id_hash();
          p.type_id = 'X';
          strncpy(p.name, txt->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          txt->add_on_state_callback([this, txt](const std::string &state) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            size_t state_len = std::min(state.length(), size_t(24));
            uint8_t pl[28];
            uint32_t hash = txt->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, state.c_str(), state_len);
            memset(pl + 4 + state_len, 0, 24 - state_len);

            this->route_packet(&dh, pl, 28);
          });
        }
        break;
      }
      #endif

      // ========== VALVE (Valvola) ==========
      #ifdef USE_VALVE
      case ENTITY_TYPE_VALVE: {
        auto *valve = static_cast<valve::Valve *>(obj.entity);
        if (valve != nullptr) {
          RegPayload p;
          p.entity_hash = valve->get_object_id_hash();
          p.type_id = 'V';
          strncpy(p.name, valve->get_name().c_str(), 23);
          p.name[23] = '\0';
          strncpy(p.unit, "%", 7);
          p.unit[7] = '\0';
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Valve: posizione apertura 0-100%
          valve->add_on_state_callback([this, valve]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[8];
            uint32_t hash = valve->get_object_id_hash();
            memcpy(pl, &hash, 4);
            float position = valve->position;
            memcpy(pl + 4, &position, 4);

            this->route_packet(&dh, pl, 8);
          });
        }
        break;
      }
      #endif

      // ========== ALARM_CONTROL_PANEL (Allarme) ==========
      #ifdef USE_ALARM_CONTROL_PANEL
      case ENTITY_TYPE_ALARM_CONTROL_PANEL: {
        auto *acp = static_cast<alarm_control_panel::AlarmControlPanel *>(obj.entity);
        if (acp != nullptr) {
          RegPayload p;
          p.entity_hash = acp->get_object_id_hash();
          p.type_id = 'A';
          strncpy(p.name, acp->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Alarm: stato (disarmed/armed_home/armed_away/triggered)
          acp->add_on_state_callback([this, acp]() {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            uint8_t pl[5];
            uint32_t hash = acp->get_object_id_hash();
            memcpy(pl, &hash, 4);
            pl[4] = static_cast<uint8_t>(acp->get_state());

            this->route_packet(&dh, pl, 5);
          });
        }
        break;
      }
      #endif

      // ========== EVENT (Evento) ==========
      #ifdef USE_EVENT
      case ENTITY_TYPE_EVENT: {
        auto *evt = static_cast<event::Event *>(obj.entity);
        if (evt != nullptr) {
          RegPayload p;
          p.entity_hash = evt->get_object_id_hash();
          p.type_id = 'V';
          strncpy(p.name, evt->get_name().c_str(), 23);
          p.name[23] = '\0';
          memset(p.unit, 0, 8);
          memset(p.dev_class, 0, 16);

          MeshHeader h;
          h.type = PKT_REG;
          h.net_id = this->net_id_hash_;
          h.ttl = 10;
          memcpy(h.src, this->my_mac_, 6);
          memcpy(h.dst, root_dst, 6);

          this->route_packet(&h, reinterpret_cast<uint8_t *>(&p), sizeof(p));
          delay(50);

          // Event: registro dei timestamp e tipo di evento
          evt->add_on_event_callback([this, evt](const std::string &event_type) {
            MeshHeader dh;
            dh.type = PKT_DATA;
            dh.net_id = this->net_id_hash_;
            dh.ttl = 10;
            memcpy(dh.src, this->my_mac_, 6);
            memset(dh.dst, 0, 6);

            size_t event_len = std::min(event_type.length(), size_t(24));
            uint8_t pl[28];
            uint32_t hash = evt->get_object_id_hash();
            memcpy(pl, &hash, 4);
            memcpy(pl + 4, event_type.c_str(), event_len);
            memset(pl + 4 + event_len, 0, 24 - event_len);

            this->route_packet(&dh, pl, 28);
          });
        }
        break;
      }
      #endif

      default:
        ESP_LOGW(TAG, "Entity type %u not supported for scanning", obj.type);
        break;
    }
  }

  ESP_LOGI(TAG, "Scanned %zu local entities", this->get_local_entities().size());
}

template<typename T>
void EspMesh::add_entities_to_local_list(const T& entities, EntityType type) {
    for (auto *entity : entities) {
        // 'entity' qui è già un puntatore (es. Sensor*)
        EntityInfo info;
        // Cast sicuro a EntityBase* (Sensor eredita da EntityBase)
        info.entity = static_cast<esphome::EntityBase*>(entity);
        info.type = type;
        this->local_entities_.push_back(info);
    }
}

std::vector<EntityInfo> EspMesh::get_local_entities() {
 if(!this->local_entities_.empty()){
    return this->local_entities_;
 }
 #ifdef USE_BINARY_SENSOR
 this->add_entities_to_local_list(App.get_binary_sensors(), ENTITY_TYPE_BINARY_SENSOR);
 #endif
 #ifdef USE_SENSOR
 this->add_entities_to_local_list(App.get_sensors(), ENTITY_TYPE_SENSOR);
 #endif
 #ifdef USE_SWITCH
 this->add_entities_to_local_list(App.get_switches(), ENTITY_TYPE_SWITCH);
 #endif
 #ifdef USE_BUTTON
  this->add_entities_to_local_list(App.get_buttons(), ENTITY_TYPE_BUTTON);
 #endif
 #ifdef USE_TEXT_SENSOR
  this->add_entities_to_local_list(App.get_text_sensors(), ENTITY_TYPE_TEXT_SENSOR);
 #endif
#ifdef USE_FAN
  this->add_entities_to_local_list(App.get_fans(), ENTITY_TYPE_FAN);
#endif
#ifdef USE_COVER
  this->add_entities_to_local_list(App.get_covers(), ENTITY_TYPE_COVER);
#endif
#ifdef USE_LIGHT
  this->add_entities_to_local_list(App.get_lights(), ENTITY_TYPE_LIGHT);
#endif
#ifdef USE_CLIMATE
  this->add_entities_to_local_list(App.get_climates(), ENTITY_TYPE_CLIMATE);
#endif
#ifdef USE_NUMBER
  this->add_entities_to_local_list(App.get_numbers(), ENTITY_TYPE_NUMBER);
#endif
#ifdef USE_DATETIME_DATE
  this->add_entities_to_local_list(App.get_dates(), ENTITY_TYPE_DATE);
#endif
#ifdef USE_DATETIME_TIME
  this->add_entities_to_local_list(App.get_times(), ENTITY_TYPE_TIME);
#endif
#ifdef USE_DATETIME_DATETIME
  this->add_entities_to_local_list(App.get_datetimes(), ENTITY_TYPE_DATETIME);
#endif
#ifdef USE_TEXT
  this->add_entities_to_local_list(App.get_texts(), ENTITY_TYPE_TEXT);
#endif
#ifdef USE_SELECT
  this->add_entities_to_local_list(App.get_selects(), ENTITY_TYPE_SELECT);
#endif
#ifdef USE_LOCK
  this->add_entities_to_local_list(App.get_locks(), ENTITY_TYPE_LOCK);
#endif
#ifdef USE_VALVE
  this->add_entities_to_local_list(App.get_valves(), ENTITY_TYPE_VALVE);
#endif
#ifdef USE_ALARM_CONTROL_PANEL
  this->add_entities_to_local_list(App.get_alarm_control_panels(), ENTITY_TYPE_ALARM_CONTROL_PANEL);
#endif
#ifdef USE_EVENT
  this->add_entities_to_local_list(App.get_events(), ENTITY_TYPE_EVENT);
#endif
#ifdef USE_UPDATE
  this->add_entities_to_local_list(App.get_updates(), ENTITY_TYPE_UPDATE);
#endif
 return this->local_entities_;

}

#endif

#ifdef IS_ROOT
void EspMesh::handle_reg(const uint8_t *origin, const RegPayload *p) {
  if (!this->mqtt_)
    return;
  char m[13];
  sprintf(m, "%02X%02X%02X%02X%02X%02X", origin[0], origin[1], origin[2], origin[3], origin[4],
          origin[5]);
  std::string uid = std::string(m) + "_" + to_string(p->entity_hash);

  std::string top = "homeassistant/sensor/" + uid + "/config";
  std::string stat = "mesh_gw/" + uid + "/state";
  std::string j = "{\"name\":\"" + std::string(p->name) + "\",\"uniq_id\":\"" + uid +
                  "\",\"stat_t\":\"" + stat + "\",\"dev\":{\"ids\":[\"" + std::string(m) +
                  "\"],\"name\":\"Node " + std::string(m) + "\"}}";
  this->mqtt_->publish(top, j, 0, true);
}
void EspMesh::handle_data(const uint8_t *origin, const uint8_t *payload) {
  if (!this->mqtt_)
    return;
  uint32_t hash;
  float val;
  memcpy(&hash, payload, 4);
  memcpy(&val, payload + 4, 4);
  char m[13];
  sprintf(m, "%02X%02X%02X%02X%02X%02X", origin[0], origin[1], origin[2], origin[3], origin[4],
          origin[5]);
  std::string uid = std::string(m) + "_" + to_string(hash);
  char vs[16];
  sprintf(vs, "%.2f", val);
  this->mqtt_->publish("mesh_gw/" + uid + "/state", vs);
}
#endif

}  // namespace esp_mesh
}  // namespace esphome`;
        }

    function genYaml(c) {
        const isRoot = c.role === 'ROOT';
        let s = `esphome:
  name: ${isRoot ? 'mesh-gateway' : 'mesh-node-01'}
  name_add_mac_suffix: true

esp32:
  board: esp32-devkitc-v4
  framework:
    type: esp-idf

external_components:
  - source: {type: local, path: components}

esp_mesh:
  mode: ${c.role}
  mesh_id: "${c.id}"
  pmk: "${c.pmk}"

`;

        if (isRoot) {
            s += `# === ROOT CONFIGURATION ===
# Richiede WiFi reale e MQTT per fare da bridge

wifi:
  ssid: "TuoSSID"
  password: "TuaPassword"

mqtt:
  broker: ${c.mqtt}
  discovery: false # Gestito dal mesh
  topic_prefix: mesh_gw
`;
        } else {
            s += `# === NODE CONFIGURATION (ZERO CONFIG) ===
# Nessuna configurazione WiFi.
# Nessuna configurazione canali.
# Definisci solo i sensori hardware.

sensor:
  - platform: template
    name: "Temperatura Sala"
    id: temp_1
    update_interval: 60s
    lambda: return 22.5; # Sostituire con sensore vero (dht, etc)

  - platform: wifi_signal
    name: "RSSI Link"
    update_interval: 10s

# Basta. Flashalo e accendilo.
# Il nodo scansionerà i canali, troverà il Root,
# si connetterà con crittografia e apparirà in Home Assistant.
`;
        }
        return s;
    }

        // --- UI LOGIC ---
        function render() {
            const c = {
                role: document.getElementById('role').value,
                id: document.getElementById('mesh_id').value,
                pmk: document.getElementById('pmk').value,
                mqtt: document.getElementById('mqtt').value
            };
            
            // Toggle UI elements
            document.getElementById('root_options').style.display = (c.role === 'ROOT') ? 'block' : 'none';

            // Generate
            files.py = genPy(c);
            files.h = genH(c);
            files.cpp = genCpp(c);
            files.yaml = genYaml(c);
            
            // Update View
            document.getElementById('output_code').textContent = files[currentTab];
        }

        function setTab(t) {
            currentTab = t;
            document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('output_code').textContent = files[t];
        }

        function copyToClipboard() {
            navigator.clipboard.writeText(files[currentTab]);
            alert("Codice copiato!");
        }

        // Init
        render();
    </script>
</body>
</html>